# FrequencyInputBox
## Тестовое задание.  

Написать WPF контрол - поле ввода значения частоты.
Данный контрой должен иметь поле Frequency с хранением значения в Гц (герцах СИ).
И отображать значение он должен с той же логикой, если значение достаточно большое для МГц то выводить в МГц, если величины хватает для кГц то выводить в кГц и т.д.
Данный контрой предназначен для многократно повторяющегося использования.
Идеальная ситуация: открыл редактор XAML добавил контрол натравил на свойство ViewModel-и и готово.

_1. Что значит «[8м]» ? там не опечатка?_
8м –означает частоту 8 МГц т.е. после того когда вы ввели 8м и нажали клавишу например Enter, значение в контроле должно стать: 8 МГц
2. Сколько знаков после запятой должно быть в поле. В принципе возможна ситуация ведь если частота равна 13 487,35 Гц — как такое значение отформатировать — округлить? как 13.487 кГц или 13.48735 кГц?\
После ввода 13 487,35 Гц значение в контроле: 13 487,35 Гц (явно указали единицы, не надо ничего менять)

_3. Не совсем понял какова логика ввода должна быть в этот контрол с клавиатуры?_
Вводим значение, нажимаем Enter.

_Допустим в поле ввода мы вбиваем цифру 15.
Как реагирует контрол? это 15 Гц? или 15 кГц или 15 МГц?_
Нажимаем Enter и должны увидеть: 15 Гц
Или вводим 15 000 нажимаем Enter и должны увидеть 15 кГц.

_Или мы вбиваем туда прямо строку «15 кГц» — и он понимает что это килогерцы?_
Да он понимает, что это килогерцы.

_Или мы вбиваем 15, а рядом добавляем чем-то вроде выпадающего списка одно из значений : Гц, кГц, МГц, ГГц…._
Нет, просто Textbox который принимает строку целиком

_Или еще есть вариант (мне кажется интересный и более удобный) — когда контрол получает фокус ввода — в нем отображается значение в Гц (например 13500 Гц), когда фокус ввода уходит — он отображает уже отформатированное значение (13,5 кГц)._
Смысл контрола упростить ввод, пользователь не хочет вводить 15 500 000 000 Гц, он хочет ввести 15,5М нажать Enter. После Enter должно появиться 15,5 МГц.

## Пояснения

### Структура решения
**FrequencyInputBoxDemo** - само приложение 
(надеюсь ничего страшного что я туда MaterialDesign добавил)

**ValueInputEVControl** - библиотека с компонентом, выполненным в соответствии с ТЗ (реагирует на Enter). Единственное код - совсем без комментариев тут.

**PhisicalValueInputControl** - библиотека с компонентом, который биндится постоянным образом (реакция на изменения в поле ввода). Кстати, тут я немного комментировал код.

Имена конечно дурацкие получились, но я не успеваю переименовать все уже...

В компонентах в основном одинаковая структура.
Класс **Unit** - это сама "физическая величина". Т.е. 44Гц или 22км - это все Unit (хотя возможно не самый удачный перевод). 
Класс **Settings** - можно сказать настройки (регулярки и шкала с обозначениями строк величин)
Класс **UnitInfo** - информация о величине - например килогерцы - их обозначения будут "kHz", "k", "кГц", их множитель 1000, обозначение по умолчанию (берется первым из списка обозначений) "kHz"

В code-behind компонентов - нечто вроде VM-ки. Но MVVM как я понимаю, для компонентов и не должна применяться. Поэтому все в Code-behind.

### Дополнительные пояснения
Поскольку я сильно просрочил задачу, я решил по объему сделать несколько больше и интересней чуть чуть (это же тестовое задание, мне как-то нужно было показать то что я могу... вообще то я себя вести с рабочими задачами так не планирую).
Я сделал два варианта. В одном привязка данных от ввода постоянная. В другом (UserControl1) - по нажатию на Enter, как Вы и ставили задачу.

Несколько отступил от задания - во первых сделал вместо поля Frequency свойство зависимости Value - это легко переименовать, почему я так его назвал - понясню ниже. Раз уж я так затянул, я решил добавить возможность легко менять шкалу и дополнять ключевые слова (типа "МГц", "М", "GHz" и т.п. ). Получилось, что можно легкоо менять шкалу и туда вносить туда любые единицы (например единицы массы, длины  и т.п.) Мне показалось, это хорошая идея, тем более она не противоречит ТЗ. Шкала меняется привязкой к DP UnitsInfoes, а название физической единицы - через DP PhisicalValueName. Соответственно, раз уж у меня универсальный контрол - странно было бы именовать его свойства как Frequency. 

Компонент сейчас работает со следующими кратными величинами для частоты:
* "Hz", "H", "Гц",
* "kHz", "k", "кГц",
* "MHz", "M", "МГц",
* "GHz", "G", "ГГц"

Если этот алфавит нужно расширить - это очень просто делается через DP UnitsInfoes

Также добавил валидацию данных (свойство Validty)

Я не стал заниматься тут SOLIDом и в ООП лезть сильно, хотя... вообще-то логику парсинга и сборки обратно строки из класса Unit было бы неплохо вынести и сделать DependencyInjection. Можно еще поработать над валидацией отрицательных величин и т.д... Но я и так затянул.

### Трудности
Я сильно застрял на этих DependencyProperty, хотя работал с ними немного, но оказалось так себе их понимаю. И еще вот эта передача управления между сеттерами и обработчиками изменений в DP, циклические зависимости одних свойств от других. Это было запутанно... 
В любом случае, независимо от того как это тестовое задание будет оценено (учитывая сроки), спасибо за интересную задачу. Ее правда было увлекательно решать. 
